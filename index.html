<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="styles.css">
  <style>
  body{
    background-color: #392f3a;
    color: #fff;
    font-family: sans-serif;
    font-size: 2em;
    text-align: center;
    display: grid;
    place-items: center;
}

div{
    margin-top: 20px;
    margin-bottom: 20px;
}


canvas{
    border:  solid .2em white;
    height: 75vh;
}
  </style>
    <title>tetris</title>
</head>
<body>
    <div>Score:<span id="score"></span>
    </div>
    <canvas id="tetris" width="240" height="400"></canvas>
    <script src="app.js">
    const canvas=document.getElementById('tetris');
const context=canvas.getContext('2d');

context.scale(20,20);


/* tetris matrices for object representation*/
/*creating more elements  and different numbers are given for colour reconisation*/
function createPiece(type){
    if(type==='T'){
        return[
                [0,0,0],    
                [1,1,1],    /* === */
                [0,1,0],    /*  =  */   
                 /*row=3,column=3 (3*3 matrix)*/
            ];
    }
    else if(type==='O'){
        return[
            [2,2],
            [2,2],
        ];
    }
    else if(type==='L'){
        return[
            [0,3,0],
            [0,3,0],
            [0,3,3],
        ];
    }
    else if(type==='J'){
        return[
            [0,4,0],
            [0,4,0],
            [4,4,0],
        ];
    }
    else if(type==='I'){
        return[
            [0,5,0,0],
            [0,5,0,0],
            [0,5,0,0],
            [0,5,0,0]
        ];
    }     
    else if(type==='S'){
        return[
            [0,6,6],
            [6,6,0],
            [0,0,0],
        ]; 
    }
    else if(type==='Z'){
        return[
            [7,7,0],
            [0,7,7],
            [0,0,0],
        ];
    }          
}

/*making of background and call the draw-matrix*/
function draw(){
    context.fillStyle='#000';
    context.fillRect(0,0,canvas.width,canvas.height);
    drawMatrix(arena,{x:0,y:0});/*to set element on by one at top*/
    drawMatrix(player.matrix,player.pos);
}

/*color for tetris */
const colors=[
    null,
    '#FF355E','#50BFE6','#66FF66','#66FF66','#FF9933','#FFCC33'
    ]

/* tetris colour element*/
function drawMatrix(matrix,offset){  
     /* (x=element values),(y=matrix positon(rows)) */
    matrix.forEach((row,y)=>{
        row.forEach((value,x)=>{
            if (value!=0){
                context.fillStyle=colors[value];
                context.fillRect(x+offset.x,y+offset.y,1,1);
            }
        });
    });
}



/*collison detection both down,right,left*/
function collide(arena,player){
    const [m,o]=[player.matrix,player.pos];
    for(let y=0;y<m.length;++y){
        for(let x=0;x<m[y].length;++x){
            if( m[y][x]!==0 && (arena[y+o.y] &&
                arena[y+o.y][x+o.x])!==0){
                    return true; 
                    /*if these condition true */ 
                }
               
        }
    }
    return false;/*no collision */
}



/*our tetris into matrix for detecting collison and all
#making our tetris to contain in matrix to chexk all the function using these big matrix cointainer */
function createMatrix(w,h){
    const matrix=[];
    while(h--){
        matrix.push(new Array(w).fill(0));
    }
    return matrix;
}

function merge(arena,player){
    player.matrix.forEach((row,y)=>{
        row.forEach((value,x)=>{
            if(value!==0){
                arena[y+player.pos.y][x+player.pos.x]=value;
            }
        });
    });
}

const arena=createMatrix(12,20);



/*update frame (movement of tetris element) */
let dropCounter=0;
let dropInterval=1000;
let lastTime=0;

function update(time=0){
    const deltaTime=time-lastTime;
    lastTime=time;

    dropCounter+=deltaTime;
    if(dropCounter>dropInterval){
        playerDrop()
    }
    draw();
    requestAnimationFrame(update);
}


/*down button drop frame value */
/*collide function *//*merge call */
function playerDrop(){
    player.pos.y++;
    if(collide(arena,player)){
        player.pos.y--;
        merge(arena,player);
        playerReset();
        arenaSweep();
        updateScore();
    }
    dropCounter=0;
}

/*tetris element border limit not to go out of the given area */
function playerMove(dir){
    player.pos.x+=dir;
    if(collide(arena,player)){
        player.pos.x-=dir;
    }
}


/*calling rotate*/
function playerRotate(dir){
    const pos=player.pos.x;
    let offset=1;
    rotate(player.matrix,dir);
    while(collide(arena,player)){
        player.pos.x+=offset;
        offset=-(offset+(offset>0 ? 1:-1));
        if(offset>player.matrix[0].length){
            rotate(player.matrix,-dir);
            player.pos.x=pos;
            return;
        }
    }
}




/*rotation function to rotate tetris (if a matrix to rotate we have to transpose and reverse each row)*/
function rotate(matrix,dir){
    for(let y=0;y<matrix.length;y++){
        for(let x=0;x<y;++x){
            [
                matrix[x][y],
                matrix[y][x],
            ] =
            [
                matrix[y][x],
                matrix[x][y],
            ];       
        }
    }
    if(dir>0){
        matrix.forEach(row => row.reverse());
    }
    else{
        matrix.reverse();
    }
}


/*keyboard listeners */
document.addEventListener('keydown',event =>{
    if(event.keyCode ===37){
        playerMove(-1);
        /* 37 is a keycode for left and 39 for right */
    }
    else if(event.keyCode===39){
        playerMove(+1);
    }
    else if(event.keyCode==40){
        playerDrop();
    }
    else if(event.keyCode==81){
        playerRotate(-1)
    }
    else if(event.keyCode==87){
        playerRotate(1)
    }
    
});


/*random tetris element call and check collide once again*/
function playerReset(){
    const pieces='ILJOTSZ'
    player.matrix=createPiece(pieces[pieces.length*Math.random()|0]);
    player.pos.y=0
    player.pos.x=(arena[0].length/2|0)-(player.matrix[0].length/2|0);
    if(collide(arena,player)){
        arena.forEach(row=>row.fill(0));
        player.score=0;
        updateScore();
    }
}


/*arena sweep to cancel if element of tetris are filled properly 
and also score if all tetris are correctly filled*/
function arenaSweep(){
    let rowcount=1;
    lo:for(let y=arena.length-1;y>0;--y){
        for(let x=0;x<arena[y].length;++x){
            if(arena[y][x]===0){
                continue lo
            }
        }
        const row=arena.splice(y,1)[0].fill(0);
        arena.unshift(row);
        ++y;
        player.score+=rowcount*10
        rowcount*=2;

    }
}

/*matrix and offset values (main)*/
const player={
    pos:{x:5,y:5},
    matrix:createPiece('T'),
    score:0
}

/*updateScore */
function updateScore(){
    document.getElementById('score').innerText=player.score
}


/*call */
update();
  </script>
</body>
</html>
